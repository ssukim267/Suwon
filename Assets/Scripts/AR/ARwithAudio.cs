using System.Collections.Generic;
using UnityEngine;
using TMPro;
using UnityEngine.XR.ARFoundation;

public class ARwithAudio : MonoBehaviour
{
    // ARTrackedImageManager를 통해 AR 이미지 추적 관리
    public ARTrackedImageManager trackedImageManager;

    // 3D 오브젝트 리스트
    public List<GameObject> _objectList = new List<GameObject>();

    // 오브젝트에 대한 설명 텍스트
    public TextMeshProUGUI objectDescriptionText;

    // 오브젝트와 음원 파일을 연결할 딕셔너리
    public Dictionary<string, AudioClip> audioDic = new Dictionary<string, AudioClip>();

    // AudioSource 컴포넌트
    private AudioSource audioSource;

    // 이미지 이름을 키로, 해당 이미지를 추적할 때 표시할 3D 오브젝트를 값으로 가지는 딕셔너리
    private Dictionary<string, GameObject> _prefabDic = new Dictionary<string, GameObject>();

    // 설명 텍스트를 미리 설정
    private Dictionary<string, string> _objectDescriptions = new Dictionary<string, string>()
    {
        {"gyojeon", "왜검교전은 일본에서 도입된 칼류의 도검무예이다. 두 사람이 마주 보고 칼을 사용하여 교전하는 형식으로 공방의 자세를 취하는 것이 특징이다."},
        {"deungpae", "등패는 중국에서 도입된 칼류의 도검무예이다. 등패와 함께 짧은 칼인 요도와 표창으로 무장하여, 먼저 표창을 던지고 이후 등패와 칼로 적을 제압하는 근접전을 펼친다."},
        {"ssanggeom", "쌍검은 중국에서 도입된 칼류의 도검무예이다. 두 개의 칼을 사용하는 기예로서 하나로는 막고 다른 칼로 상대를 베거나 찌른다."},
        {"ssangsudo", "쌍수도는 일본에서 도입된 칼류의 도검무예이다. 모든 검법의 기본으로서 검의 운용에 필요한 발도술, 베기, 막기, 찌르기, 착검술, 안법, 보법 등으로 이루어져 있다."},
        {"nangseon", "낭선은 중국에서 도입된 창류의 단병무예이다. 낭선은 대나무 가지에 작은 쇠 날을 9개에서 11개를 달아 만든 무기로 찌르는 형태의 자법을 사용하고 있다."},
        {"dangpa", "당파는 중국에서 도입된 창류의 무기이다. 정봉이라고 불리는 가운데의 긴 날과 양쪽으로 두 개의 가지가 뻗은 모양을 갖고 있다."},
        {"woldo", "월도는 중국에서 도입된 칼류의 도검무예이다. 도의 형태로 찍어 베는 감법을 사용하고 있다."},
        {"hyeopdo", "협도는 중국에서 도입된 칼류의 도검무예이다. 장검처럼 눈썹 모양을 하고 도를 이용하여 찍어 베는 형태의 감법을 사용하고 있다."},
        {"gwonbeop", "권법은 손과 발을 이용하여 상대방을 공격하거나 방어하는 맨손 무예이다. 무예를 배우는 자가 가장 먼저 익히는 기초적인 무예로서 주먹으로 치는 형태의 격법을 사용하고 있다."},
    };

    // 오브젝트를 담고 있는 부모 오브젝트
    public GameObject ObjectPool;

    // 오브젝트 확대 및 축소
    private float previousTouchDistance = 0;
    private Vector3 initialScale;

    // 오브젝트 회전
    private float previousTouchPositionX = 0f;
    private float startRotationY = 0f;

    void Awake()
    {
        audioSource = GetComponent<AudioSource>();

        // 오브젝트 리스트에 있는 3D 오브젝트를 이름과 함께 딕셔너리에 추가
        foreach (GameObject obj in _objectList)
        {
            string tName = obj.name;
            _prefabDic.Add(tName, obj); // 오브젝트 이름을 키로 딕셔너리에 저장
        }
    }

    private void OnEnable()
    {
        // 이미지가 추적되거나 업데이트될 때 호출되는 이벤트 핸들러 등록
        trackedImageManager.trackedImagesChanged += ImageChanged;
    }

    private void OnDisable()
    {
        // 컴포넌트가 비활성화되면 이벤트 핸들러 해제
        trackedImageManager.trackedImagesChanged -= ImageChanged;
    }

    void Update()
    {
        if (Input.touchCount == 2)
        {
            ChangeScale();
        }
        else if (Input.touchCount == 1)
        {
            OnTouchRotate();
        }
    }

    void ChangeScale()
    {
        Touch touch1 = Input.GetTouch(0);
        Touch touch2 = Input.GetTouch(1);

        if (touch1.phase == TouchPhase.Began || touch2.phase == TouchPhase.Began)
        {
            previousTouchDistance = Vector2.Distance(touch1.position, touch2.position);
            initialScale = ObjectPool.transform.localScale;
        }
        else if (touch1.phase == TouchPhase.Moved || touch2.phase == TouchPhase.Moved)
        {
            float currentTouchDistance = Vector2.Distance(touch1.position, touch2.position);
            if (Mathf.Approximately(previousTouchDistance, 0)) return;

            float scaleFactor = currentTouchDistance / previousTouchDistance;
            ObjectPool.transform.localScale = initialScale * scaleFactor;
        }
    }

    void OnTouchRotate()
    {
        if (Input.touchCount == 1)
        {
            Touch touch = Input.GetTouch(0);

            if (touch.phase == TouchPhase.Began)
            {
                previousTouchPositionX = touch.position.x;
                startRotationY = ObjectPool.transform.eulerAngles.y;
            }
            else if (touch.phase == TouchPhase.Moved)
            {
                float deltaPositionX = touch.position.x - previousTouchPositionX;
                float rotationFactor = deltaPositionX * 0.2f;
                float newRotationY = startRotationY + rotationFactor;
                ObjectPool.transform.rotation = Quaternion.Euler(0, newRotationY, 0);
            }
        }
    }

    private void ImageChanged(ARTrackedImagesChangedEventArgs eventArgs)
    {
        foreach (ARTrackedImage trackedImage in eventArgs.added)
        {
            if (trackedImage != null)
            {
                UpdateImage(trackedImage);
                PlayAudio(trackedImage.referenceImage.name); // 이미지에 해당하는 음원 재생
            }
            else
            {
                Debug.LogWarning("Null trackedImage in added event.");
            }
        }

        foreach (ARTrackedImage trackedImage in eventArgs.updated)
        {
            if (trackedImage != null)
            {
                UpdateImage(trackedImage);
                PlayAudio(trackedImage.referenceImage.name);
            }
            else
            {
                Debug.LogWarning("Null trackedImage in updated event.");
            }
        }

        foreach (ARTrackedImage trackedImage in eventArgs.removed)
        {
            if (trackedImage != null)
            {
                DisableImage(trackedImage);
            }
            else
            {
                Debug.LogWarning("Null trackedImage in removed event.");
            }
        }
    }

    // 이미지에 해당하는 오브젝트의 위치와 회전을 업데이트하고 오브젝트 활성화
    private void UpdateImage(ARTrackedImage trackedImage)
    {
        string name = trackedImage.referenceImage.name;

        if (_prefabDic.ContainsKey(name))
        {
            GameObject tObj = _prefabDic[name];
            tObj.transform.position = trackedImage.transform.position;
            tObj.SetActive(true);

            if (_objectDescriptions.ContainsKey(name))
            {
                string description = _objectDescriptions[name];
                objectDescriptionText.text = description;
                objectDescriptionText.gameObject.SetActive(true);
            }
        }
        else
        {
            Debug.LogWarning("No prefab found for tracked image: " + name);
        }
    }



    // 이미지 추적 중지 시 해당 오브젝트 비활성화
    private void DisableImage(ARTrackedImage trackedImage)
    {
        string name = trackedImage.referenceImage.name;

        if (_prefabDic.ContainsKey(name))
        {
            GameObject tObj = _prefabDic[name];
            tObj.SetActive(false);

            // 이미지 추적이 중지될 때마다 음원 재생 상태 초기화
            isAudioPlayed = false;
        }
        else
        {
            Debug.LogWarning("No prefab found for tracked image to disable: " + name);
        }
    }


    // 이미지에 해당하는 음원 재생
    public List<AudioClip> audioList = new List<AudioClip>(); // 오디오 클립 리스트

    private bool isAudioPlayed = false; // 음원이 이미 재생되었는지 여부를 추적하는 변수

    // 이미지를 기준으로 음원 재생
    private void PlayAudio(string imageName)
    {
        // 리스트에서 음원 찾기 (이미지 이름을 기준으로 매칭)
        int audioIndex = GetAudioIndexForImage(imageName);

        if (audioIndex >= 0 && audioIndex < audioList.Count)
        {
            AudioClip clip = audioList[audioIndex];

            // 음원이 재생 중인지 확인
            if (audioSource.isPlaying)
            {
                Debug.Log("오디오가 재생중입니다");
                return;  // 음원이 이미 재생 중이면 재생을 중지하고 반환
            }

            audioSource.clip = clip;
            audioSource.Play();
            isAudioPlayed = true;  // 음원이 재생되었음을 표시
        }
        else
        {
            Debug.LogWarning("이 이미지에 해당하는 음원이 없습니다: " + imageName);
        }
    }

    private int GetAudioIndexForImage(string imageName)
    {
        // 이미지 이름에 맞는 음원 인덱스를 반환하는 매핑 로직
        Dictionary<string, int> imageAudioIndexMap = new Dictionary<string, int>()
    {
        { "gyojeon", 0 },
        { "deungpae", 1 },
        { "ssanggeom", 2 },
        { "ssangsudo", 3 },
        { "nangseon", 4 },
        { "dangpa", 5 },
        { "woldo", 6 },
        { "hyeopdo", 7 },
        { "gwonbeop", 8 }
        // 추가적으로 필요한 이미지와 음원 인덱스 매핑 추가 가능
    };

        // 이미지 이름이 딕셔너리에 있는지 확인하고, 있으면 해당 인덱스를 반환
        if (imageAudioIndexMap.ContainsKey(imageName))
        {
            return imageAudioIndexMap[imageName];
        }
        else
        {
            return -1;  // 해당하는 음원이 없으면 -1을 반환
        }
    }

}
